<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web App Layout</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <div class="column" id="column_left">
            <div class="midiToggle"></div>
            <div class="pad" id="pad8"></div>
            <div id="padPanel">
                <div class="row">
                    <div class="row padRow">
                        <div class="pad" id="pad1"><span>1</span></div>
                        <div class="pad" id="pad2"><span>2</span></div>
                        <div class="pad" id="pad3"><span>3</span></div>
                    </div>
                </div>
                <div class="row">
                    <div class="row padRow">
                        <div class="pad" id="pad4"><span>4</span></div>
                        <div class="pad" id="pad5"><span>5</span></div>
                        <div class="pad" id="pad6"><span>6</span></div>
                    </div>
                </div>
                <div class="row">
                    <div class="row padRow">
                        <div class="pad" id="padManual"><span>Manual</span></div>
                    </div>
                </div>   
            </div>
        </div>
        <div class="center-column">
            <div class="center_box_container">
                <div class="center-box">
                    <form class="box" method="post" action="/upload" enctype="multipart/form-data">
                        <div class="box__input">
                            <input class="box__file" type="file" name="files[]" id="file" accept="video/*" />
                            <label for="file"><strong>Drag it here</strong></label>
                        </div>
                        <div class="box__uploading">Uploading…</div>
                        <div class="box__success">Done!</div>
                        <div class="box__error">Error! <span></span>.</div>
                    </form>
                </div>
            </div>
            
            <div class="row">
                <div class="bottom-box">
                    <div class="row">                       
                        <div class="knob-surround">
                            <div class="knob" id="knob1"></div>
                        </div>
                        <div id="preview_display">
                            <div class="line" id="movingLine"></div>
                            <div class="small_line" id="line1">
                                <div class="movablePoint" id="point1">
                                    <span class="pointText">1</span>
                                </div>
                            </div>
                            <div class="small_line" id="line2">
                                <div class="movablePoint" id="point2">
                                    <span class="pointText">2</span>
                                </div>
                            </div>
                            <div class="small_line" id="line3">
                                <div class="movablePoint" id="point3">
                                    <span class="pointText">3</span>
                                </div>
                            </div>
                            <div class="small_line" id="line4">
                                <div class="movablePoint" id="point4">
                                    <span class="pointText">4</span>
                                </div>
                            </div>
                            <div class="small_line" id="line5">
                                <div class="movablePoint" id="point5">
                                    <span class="pointText">5</span>
                                </div>
                            </div>
                            <div class="small_line" id="line6">
                                <div class="movablePoint" id="point6">
                                    <span class="pointText">6</span>
                                </div>
                            </div>
                        </div>
                        <div class="knob-surround">
                            <div class="knob" id="knob2"></div>
                        </div>
                    </div>
                    <div class="row button-row">
                        <!-- Buttons -->
                        <button class="button" id="button1"></button>
                        <button class="button" id="button2"></button>
                        <button class="button" id="button3"></button>
                        <button class="button" id="button4"></button>
                        <button class="button" id="button5"></button>
                        <button class="button" id="button6"></button>
                    </div>
                    <div class="row lamp-row">
                        <!-- Lamps -->
                        <div class="lamp" id="lamp1">1</div>
                        <div class="lamp" id="lamp2">2</div>
                        <div class="lamp" id="lamp3">3</div>
                        <div class="lamp" id="lamp4">4</div>
                        <div class="lamp" id="lamp5">5</div>
                        <div class="lamp" id="lamp6">6</div>
                    </div>
                    <div class="row">
                        <div class="signature">
                            Les Lunettes de Dalì
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="column" id="column_right"></div>
    </div>

    <!-- All JavaScript moved below the body content to ensure DOM elements are loaded -->
    <script>
document.addEventListener('DOMContentLoaded', function() {
    const $input = document.querySelector('.box__file');
    let videoFrames = []; // Array for video frames

    // Check WebCodecs API support
    if (!window.VideoDecoder) {
        alert('WebCodecs API is not supported in this browser.');
        return;
    }

    $input.addEventListener('change', function(e) {
        const files = e.target.files;
        if (files.length > 0) {
            const file = files[0];
            if (file.type.startsWith('video/')) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const videoBuffer = event.target.result;
                    extractFramesUsingWebCodecs(videoBuffer);
                };
                reader.readAsArrayBuffer(file); // Read video as ArrayBuffer
            } else {
                alert('Please upload a video file.');
            }
        }
    });

    async function extractFramesUsingWebCodecs(videoBuffer) {
        const videoFrames = [];  // Array for storing frames

        const init = {
            output: (frame) => {
                videoFrames.push(frame);
                console.log('Decoded frame: ', frame);
            },
            error: (e) => {
                console.error('Decoding error: ', e);
            }
        };

        const videoDecoder = new VideoDecoder(init);

        const track = await createVideoTrack(videoBuffer);

        // Ensure the description is valid and non-detached
        const description = track.spsPpsData ? new Uint8Array(track.spsPpsData).buffer : null;

        // Configure the video decoder with codec information and SPS/PPS (description)
        videoDecoder.configure({
            codec: track.codec || 'avc1.42E01E', // Specify default H.264 codec
            codedWidth: track.width,
            codedHeight: track.height,
            description: description, // SPS/PPS data as ArrayBuffer
        });

        for (const chunk of track.chunks) {
            // Ensure each chunk is an EncodedVideoChunk object
            const encodedChunk = new EncodedVideoChunk({
                type: chunk.isKeyFrame ? 'key' : 'delta',
                timestamp: chunk.timestamp,
                duration: chunk.duration,
                data: chunk.data, // Use chunk.data for ArrayBuffer data
            });
            videoDecoder.decode(encodedChunk);
        }

        console.log('Extraction completed. Frames: ', videoFrames);
    }

    async function createVideoTrack(videoBuffer) {
        const videoTrack = {
            codec: '',
            width: 0,
            height: 0,
            chunks: [],
            spsPpsData: null, // Store the SPS/PPS data for H.264
        };

        const mediaSource = new MediaSource();
        const videoBlob = new Blob([videoBuffer]);
        const videoUrl = URL.createObjectURL(videoBlob);
        const video = document.createElement('video');
        
        video.src = videoUrl;
        video.controls = true; // Add controls for user to play video
        const centerBox = document.querySelector('.center-box');
        centerBox.appendChild(video); // Append the video inside center-box

        return new Promise((resolve) => {
            video.addEventListener('loadedmetadata', function () {
                videoTrack.width = video.videoWidth;
                videoTrack.height = video.videoHeight;

                // Assume codec for H.264, or use future APIs to get codec
                videoTrack.codec = 'avc1.42E01E';

                // Extract SPS and PPS data (initialization segment)
                videoTrack.spsPpsData = extractSpsPpsData(videoBuffer);

                videoTrack.chunks = splitVideoIntoChunks(videoBuffer); // Divide video buffer into chunks
                resolve(videoTrack);
            });
        });
    }


            //PAD BUTTONS
            // Funzione per cambiare il colore di sfondo a rosso acceso
 // Variabile per tenere traccia dell'elemento attivo
 let activeElement = null;
let mapActive = false; // Stato di pad8
let videoPosition = 0; // Posizione del video
let pad8 = document.getElementById('pad8'); // Assumendo che pad8 abbia id 'pad8'

// Funzione per disattivare tutti i pad (escluso pad8)
function deactivateAllPads(excludePad8 = false) {
    document.querySelectorAll(".pad").forEach(function(pad) {
        if (!excludePad8 || pad !== pad8) {
            pad.classList.remove('active'); // Rimuove la classe 'active' da tutti i pad
        }
    });
    if (!excludePad8) {
        activeElement = null;
    }
}

document.querySelectorAll(".pad").forEach(function(pad, index) {
    pad.addEventListener("click", function() {
        if (pad === pad8) {
            // Se clicchi su pad8
            if (mapActive) {
                // Se è già attivo, disattivalo e disattiva tutti gli altri pad
                pad8.classList.remove('active');
                mapActive = false;
                deactivateAllPads(); // Disattiva anche gli altri pad
            } else {
                // Altrimenti attivalo e disattiva tutti gli altri pad
                pad8.classList.add('active');
                mapActive = true;
                deactivateAllPads(true); // Disattiva tutti gli altri pad ma non pad8
                activeElement = pad8;
            }
        } else {
            // Se clicchi su un pad diverso da pad8 (da 1 a 7)
            if (mapActive) {
                // Se pad8 è attivo, non disattivarlo, ma attiva il nuovo pad e chiama la funzione 'salvatore'
                if (activeElement !== pad) {
                    // Attiva il nuovo pad solo se non è già attivo
                    if (activeElement && activeElement !== pad8) {
                        // Disattiva il vecchio pad attivo se non è pad8
                        activeElement.classList.remove('active');
                    }
                    pad.classList.add('active');
                    activeElement = pad; // Imposta il nuovo pad come attivo
                    midiConnectionFunction(); // Funzione da eseguire per fare la mappatura midi del bottone
                }
            } else {
                // Se pad8 non è attivo, attiva solo un pad alla volta
                if (activeElement) {
                    activeElement.classList.remove('active');
                }
                pad.classList.add('active');
                activeElement = pad;
                videoPosition = lampPosition[index]; // Aggiorna la posizione del video in base all'indice del pad
            }
        }
    });
});






            //SPACEBAR TO START VIDEO
            document.addEventListener('keydown', function(event) {
                if (event.code === 'Space' && videoElement) {
                    event.preventDefault();
                    if (videoElement.paused) {
                        videoElement.play();
                    } else {
                        videoElement.pause();
                    }
                }
            });



        });






////////////////////////////
/*
        document.addEventListener('DOMContentLoaded', function() {
            var $input = document.querySelector('.box__file');
            var $form = document.querySelector('.center-box');
            var videoElement = null;

            $input.addEventListener('change', function(e) {
                var files = e.target.files;
                if (files.length > 0) {
                    var file = files[0];
                    if (file.type.startsWith('video/')) {
                        var reader = new FileReader();
                        reader.onload = function(event) {
                            videoElement = document.createElement('video');
                            videoElement.classList.add('custom-video');
                            videoElement.src = event.target.result;
                            videoElement.muted = false;
                            videoElement.controls = false;
                            $form.innerHTML = '';
                            $form.appendChild(videoElement);
                        };
                        reader.readAsDataURL(file);
                    } else {
                        alert('Per favore carica un file video.');
                    }
                }
            });

            document.addEventListener('keydown', function(event) {
                if (event.code === 'Space' && videoElement) {
                    event.preventDefault();
                    if (videoElement.paused) {
                        videoElement.play();
                    } else {
                        videoElement.pause();
                    }
                }
            });
        });
*/


// This is the positions of the 7 indicators
let lampPosition = new Array(7);
        document.addEventListener('DOMContentLoaded', function () {
            const previewDisplay = document.getElementById('preview_display');
            const line = document.querySelector('.line');

            previewDisplay.addEventListener('click', function (event) {
                const rect = previewDisplay.getBoundingClientRect();
                const x = event.clientX - rect.left;
                lampPosition[6] = Math.max(0, Math.min(x, previewDisplay.offsetWidth - line.offsetWidth));
                line.style.left = lampPosition[6] + 'px';
            });
        });

        document.addEventListener('DOMContentLoaded', function () {
    // Seleziona tutti i bottoni, i lamp e le small_line
    const lampButtons = document.querySelectorAll('.button');
    const lamps = document.querySelectorAll('.lamp');
    const movablePoint = document.querySelectorAll('.movablePoint');
    const midiToggle = document.querySelector('.midiToggle');

    navigator.permissions.query({ name: "midi", sysex: true }).then((result) => {
    if (result.state === "granted") {
        alert('MIDI Connection Allowed')
    } else if (result.state === "prompt") {
        alert('Allow MIDI Connection')
    }
    // Permission was denied by user prompt or permission policy
    });

    let midi = null; // global MIDIAccess object
    function onMIDISuccess(midiAccess) {
    console.log("MIDI ready!");
    midi = midiAccess; // store in the global (in real usage, would probably keep in an object instance)
    listInputsAndOutputs(midiAccess);
    }

    function onMIDIFailure(msg) {
    console.error(`Failed to get MIDI access - ${msg}`);
    }


    function onMIDIMessage(event) {
    let str = `MIDI message received at timestamp ${event.timeStamp}[${event.data.length} bytes]: `;
    for (const character of event.data) {
        str += `0x${character.toString(16)} `;
    }
        console.log(str);
    }

    function startLoggingMIDIInput(midiAccess) {
        midiAccess.inputs.forEach((entry) => {
        entry.onmidimessage = onMIDIMessage;
    });
    }

    navigator.requestMIDIAccess().then((access) => {
    // Get lists of available MIDI controllers
    const inputs = access.inputs.values();
    const outputs = access.outputs.values();
    
    access.onstatechange = (event) => {
        // Print information about the (dis)connected MIDI controller
        console.log(event.port.name, event.port.manufacturer, event.port.state);
    };
    });

  

    navigator.requestMIDIAccess().then((midiAccess) => {
    Array.from(midiAccess.inputs).forEach((input) => {
        input[1].onmidimessage = (msg) => {
            midiToggle.classList.toggle('on');
            setTimeout(() => {
                midiToggle.classList.toggle('on');
            }, 100);

            if(msg.data[1]===24 && msg.data[2]>0){               
                    let pad1 = document.getElementById('pad1')
                    pad1.click();
                }
           
        };
    });
    });








    lampButtons.forEach((button, index) => {
        button.addEventListener('click', () => {
        // Spegni tutti i lamp
        lamps.forEach((lamp, lampIndex) => {
            if (lampIndex !== index) {
                lamp.classList.remove('on'); // Spegni lamp non selezionato
                // if (movablePoint[lampIndex]) {
                //     // Nascondi le small_line corrispondenti
                //    // movablePoint[lampIndex].style.visibility = 'hidden';
                //    // movablePoint[lampIndex].style.opacity = 0;
                // }
            }
        })
            // Toggle dello stato del lamp (accende/spegne)
            if (lamps[index]) {
                lamps[index].classList.toggle('on');
                 // Aggiunge/rimuove la classe 'on'
            }

            // Rendi visibile la small_line corrispondente solo se il lamp è acceso
            // if (movablePoint[index]) {
            //     if (lamps[index].classList.contains('on')) {
                    movablePoint[index].style.visibility = 'visible';
           //         movablePoint[index].style.opacity = 1;
                   
            //     } else {
            //         // Se il lamp è spento, nascondi la small_line
            //         movablePoint[index].style.visibility = 'hidden';
            //         movablePoint[index].style.opacity = 0;
            //     }
            // }

        });      
    });       
});


  
    </script>
    <script type="text/javascript" src="/jquery-3.7.1.js"></script>
    <script type="text/javascript" src="/java.js"></script>
</body>
</html>
