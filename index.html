<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web App Layout</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <div class="column" id="column_left">
            <div class="midiToggle"></div>
            <div class="pad" id="pad8"></div>
            <div id="padPanel">
                <div class="row">
                    <div class="row padRow">
                        <div class="pad" id="pad1"><span>1</span></div>
                        <div class="pad" id="pad2"><span>2</span></div>
                        <div class="pad" id="pad3"><span>3</span></div>
                    </div>
                </div>
                <div class="row">
                    <div class="row padRow">
                        <div class="pad" id="pad4"><span>4</span></div>
                        <div class="pad" id="pad5"><span>5</span></div>
                        <div class="pad" id="pad6"><span>6</span></div>
                    </div>
                </div>
                <div class="row">
                    <div class="row padRow">
                        <div class="pad" id="padManual"><span>Manual</span></div>
                    </div>
                </div>   
            </div>
        </div>
        <div class="center-column">
            <div class="center_box_container">
                <div class="center-box">
                    <form class="box" method="post" action="/upload" enctype="multipart/form-data">
                        <div class="box__input">
                            <input class="box__file" type="file" name="files[]" id="file" accept="video/*" />
                            <label for="file"><strong>Drag it here</strong></label>
                        </div>
                        <div class="box__uploading">Uploading…</div>
                        <div class="box__success">Done!</div>
                        <div class="box__error">Error! <span></span>.</div>
                    </form>
                </div>
            </div>
            
            <div class="row">
                <div class="bottom-box">
                    <div class="row">                       
                        <div class="knob-surround">
                            <div class="knob" id="knob1"></div>
                        </div>
                        <div id="preview_display">
                            <div class="line" id="movingLine"></div>
                            <div class="small_line" id="line1">
                                <div class="movablePoint" id="point1">
                                    <span class="pointText">1</span>
                                </div>
                            </div>
                            <div class="small_line" id="line2">
                                <div class="movablePoint" id="point2">
                                    <span class="pointText">2</span>
                                </div>
                            </div>
                            <div class="small_line" id="line3">
                                <div class="movablePoint" id="point3">
                                    <span class="pointText">3</span>
                                </div>
                            </div>
                            <div class="small_line" id="line4">
                                <div class="movablePoint" id="point4">
                                    <span class="pointText">4</span>
                                </div>
                            </div>
                            <div class="small_line" id="line5">
                                <div class="movablePoint" id="point5">
                                    <span class="pointText">5</span>
                                </div>
                            </div>
                            <div class="small_line" id="line6">
                                <div class="movablePoint" id="point6">
                                    <span class="pointText">6</span>
                                </div>
                            </div>
                        </div>
                        <div class="knob-surround">
                            <div class="knob" id="knob2"></div>
                        </div>
                    </div>
                    <div class="row button-row">
                        <!-- Buttons -->
                        <button class="button" id="button1"></button>
                        <button class="button" id="button2"></button>
                        <button class="button" id="button3"></button>
                        <button class="button" id="button4"></button>
                        <button class="button" id="button5"></button>
                        <button class="button" id="button6"></button>
                    </div>
                    <div class="row lamp-row">
                        <!-- Lamps -->
                        <div class="lamp" id="lamp1">1</div>
                        <div class="lamp" id="lamp2">2</div>
                        <div class="lamp" id="lamp3">3</div>
                        <div class="lamp" id="lamp4">4</div>
                        <div class="lamp" id="lamp5">5</div>
                        <div class="lamp" id="lamp6">6</div>
                    </div>
                    <div class="row">
                        <div class="signature">
                            Les Lunettes de Dalì
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="column" id="column_right"></div>
    </div>

    <!-- All JavaScript moved below the body content to ensure DOM elements are loaded -->
    <script>
document.addEventListener('DOMContentLoaded', function() {
    const $input = document.querySelector('.box__file');
    let videoFrames = []; // Array for video frames

    // Check WebCodecs API support
    if (!window.VideoDecoder) {
        alert('WebCodecs API is not supported in this browser.');
        return;
    }

    $input.addEventListener('change', function(e) {
        const files = e.target.files;
        if (files.length > 0) {
            const file = files[0];
            if (file.type.startsWith('video/')) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const videoBuffer = event.target.result;
                    extractFramesUsingWebCodecs(videoBuffer);
                };
                reader.readAsArrayBuffer(file); // Read video as ArrayBuffer
            } else {
                alert('Please upload a video file.');
            }
        }
    });

    async function extractFramesUsingWebCodecs(videoBuffer) {
        const videoFrames = [];  // Array for storing frames

        const init = {
            output: (frame) => {
                videoFrames.push(frame);
                console.log('Decoded frame: ', frame);
            },
            error: (e) => {
                console.error('Decoding error: ', e);
            }
        };

        const videoDecoder = new VideoDecoder(init);

        const track = await createVideoTrack(videoBuffer);

        // Ensure the description is valid and non-detached
        const description = track.spsPpsData ? new Uint8Array(track.spsPpsData).buffer : null;

        // Configure the video decoder with codec information and SPS/PPS (description)
        videoDecoder.configure({
            codec: track.codec || 'avc1.42E01E', // Specify default H.264 codec
            codedWidth: track.width,
            codedHeight: track.height,
            description: description, // SPS/PPS data as ArrayBuffer
        });

        for (const chunk of track.chunks) {
            // Ensure each chunk is an EncodedVideoChunk object
            const encodedChunk = new EncodedVideoChunk({
                type: chunk.isKeyFrame ? 'key' : 'delta',
                timestamp: chunk.timestamp,
                duration: chunk.duration,
                data: chunk.data, // Use chunk.data for ArrayBuffer data
            });
            videoDecoder.decode(encodedChunk);
        }

        console.log('Extraction completed. Frames: ', videoFrames);
    }

    async function createVideoTrack(videoBuffer) {
        const videoTrack = {
            codec: '',
            width: 0,
            height: 0,
            chunks: [],
            spsPpsData: null, // Store the SPS/PPS data for H.264
        };

        const mediaSource = new MediaSource();
        const videoBlob = new Blob([videoBuffer]);
        const videoUrl = URL.createObjectURL(videoBlob);
        const video = document.createElement('video');
        
        video.src = videoUrl;
        video.controls = true; // Add controls for user to play video
        const centerBox = document.querySelector('.center-box');
        centerBox.appendChild(video); // Append the video inside center-box

        return new Promise((resolve) => {
            video.addEventListener('loadedmetadata', function () {
                videoTrack.width = video.videoWidth;
                videoTrack.height = video.videoHeight;

                // Assume codec for H.264, or use future APIs to get codec
                videoTrack.codec = 'avc1.42E01E';

                // Extract SPS and PPS data (initialization segment)
                videoTrack.spsPpsData = extractSpsPpsData(videoBuffer);

                videoTrack.chunks = splitVideoIntoChunks(videoBuffer); // Divide video buffer into chunks
                resolve(videoTrack);
            });
        });
    }

    // Function to extract SPS/PPS data from H.264 bitstream
    function extractSpsPpsData(videoBuffer) {
        const SPS_NAL_UNIT = 7;
        const PPS_NAL_UNIT = 8;

        let sps = null;
        let pps = null;

        // Search for NAL units in the buffer
        let i = 0;
        while (i < videoBuffer.byteLength) {
            // Look for the start of a NAL unit (0x00 00 00 01)
            if (videoBuffer[i] === 0x00 && videoBuffer[i+1] === 0x00 && videoBuffer[i+2] === 0x00 && videoBuffer[i+3] === 0x01) {
                const nalUnitType = videoBuffer[i+4] & 0x1F;

                if (nalUnitType === SPS_NAL_UNIT) {
                    // Found SPS
                    const spsStart = i + 4;
                    const spsEnd = findNalUnitEnd(videoBuffer, spsStart);
                    sps = new Uint8Array(videoBuffer.slice(spsStart, spsEnd));
                } else if (nalUnitType === PPS_NAL_UNIT) {
                    // Found PPS
                    const ppsStart = i + 4;
                    const ppsEnd = findNalUnitEnd(videoBuffer, ppsStart);
                    pps = new Uint8Array(videoBuffer.slice(ppsStart, ppsEnd));
                }

                if (sps && pps) {
                    break; // Stop searching once we've found both SPS and PPS
                }
            }
            i++;
        }

        if (sps && pps) {
            const spsPpsHeader = new Uint8Array([0x00, 0x00, 0x00, 0x01]);
            // Concatenate SPS and PPS with start code (non-detached buffer)
            const spsPpsData = new Uint8Array(spsPpsHeader.length + sps.length + spsPpsHeader.length + pps.length);
            spsPpsData.set(spsPpsHeader, 0);
            spsPpsData.set(sps, spsPpsHeader.length);
            spsPpsData.set(spsPpsHeader, spsPpsHeader.length + sps.length);
            spsPpsData.set(pps, spsPpsHeader.length + sps.length + spsPpsHeader.length);

            return spsPpsData.buffer; // Return as ArrayBuffer
        } else {
            console.error('Failed to extract SPS/PPS');
            return null;
        }
    }

    function findNalUnitEnd(buffer, start) {
        for (let i = start; i < buffer.byteLength - 4; i++) {
            if (buffer[i] === 0x00 && buffer[i+1] === 0x00 && buffer[i+2] === 0x00 && buffer[i+3] === 0x01) {
                return i;
            }
        }
        return buffer.byteLength; // If no next NAL unit found, return the end of the buffer
    }

    function splitVideoIntoChunks(videoBuffer) {
        const chunkSize = 1024 * 1024; // Define suitable chunk size
        const chunks = [];
        let offset = 0;

        while (offset < videoBuffer.byteLength) {
            const chunkData = videoBuffer.slice(offset, offset + chunkSize);
            
            // Create an EncodedVideoChunk-like structure for demo purposes
            const chunk = {
                timestamp: offset, // Use offset as a mock timestamp
                duration: 0,       // You can estimate the duration here if needed
                isKeyFrame: (offset === 0), // Assume the first chunk is a key frame
                data: chunkData     // Actual chunk data
            };
            
            chunks.push(chunk);
            offset += chunkSize;
        }

        return chunks;
    }



            //PAD BUTTONS
            // Funzione per cambiare il colore di sfondo a rosso acceso
 // Variabile per tenere traccia dell'elemento attivo
 let activeElement = null;
let mapActive = false;
// Video position in time
var videoPosition = 0;
document.querySelectorAll(".pad").forEach(function(pad, index) {
    pad.addEventListener("click", function() {
        if (activeElement) {
            activeElement.classList.remove('active');
            // Rimuove la classe 'active' dall'elemento attivo
            if(activeElement === 'pad8') {
                
                mapActive = false;
            }
        }
        if (activeElement === pad) {
            activeElement = null; // Nessun elemento attivo
        } else {
            pad.classList.add('active'); // Aggiunge la classe 'active' all'elemento cliccato
            activeElement = pad; // Imposta l'elemento cliccato come attivo
            if(activeElement === 'pad8') {
                mapActive = true;
                
            }
            if(mapActive) {
          
            } else { 
                videoPosition = lampPosition[index];
            }

           
        }
    });
});

            //SPACEBAR TO START VIDEO
            document.addEventListener('keydown', function(event) {
                if (event.code === 'Space' && videoElement) {
                    event.preventDefault();
                    if (videoElement.paused) {
                        videoElement.play();
                    } else {
                        videoElement.pause();
                    }
                }
            });

            // Funzione per estrarre i frame dal video
            function extractFramesFromVideo(video) {
                var duration = video.duration;  // Durata totale del video
                var fps = 25;  // Frame per secondo (modificabile in base al frame rate desiderato)
                var interval = 1 / fps;  // Intervallo tra i frame

                video.currentTime = 0;  // Inizia dal tempo zero

                video.addEventListener('seeked', function onSeeked() {
                    // Disegna il frame corrente su canvas
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    var frameData = canvas.toDataURL();  // Ottieni il frame come base64
                    videoFrames.push(frameData);  // Aggiungi il frame all'array

                    if (video.currentTime < duration) {
                        // Avanza al prossimo frame
                        video.currentTime += interval;
                    } else {
                        // Rimuovi il listener quando il video è finito
                        video.removeEventListener('seeked', onSeeked);
                        console.log('Estrazione frame completata', videoFrames);
                    }
                });
            }


        });






////////////////////////////
/*
        document.addEventListener('DOMContentLoaded', function() {
            var $input = document.querySelector('.box__file');
            var $form = document.querySelector('.center-box');
            var videoElement = null;

            $input.addEventListener('change', function(e) {
                var files = e.target.files;
                if (files.length > 0) {
                    var file = files[0];
                    if (file.type.startsWith('video/')) {
                        var reader = new FileReader();
                        reader.onload = function(event) {
                            videoElement = document.createElement('video');
                            videoElement.classList.add('custom-video');
                            videoElement.src = event.target.result;
                            videoElement.muted = false;
                            videoElement.controls = false;
                            $form.innerHTML = '';
                            $form.appendChild(videoElement);
                        };
                        reader.readAsDataURL(file);
                    } else {
                        alert('Per favore carica un file video.');
                    }
                }
            });

            document.addEventListener('keydown', function(event) {
                if (event.code === 'Space' && videoElement) {
                    event.preventDefault();
                    if (videoElement.paused) {
                        videoElement.play();
                    } else {
                        videoElement.pause();
                    }
                }
            });
        });
*/


// This is the positions of the 7 indicators
let lampPosition = new Array(7);
        document.addEventListener('DOMContentLoaded', function () {
            const previewDisplay = document.getElementById('preview_display');
            const line = document.querySelector('.line');

            previewDisplay.addEventListener('click', function (event) {
                const rect = previewDisplay.getBoundingClientRect();
                const x = event.clientX - rect.left;
                lampPosition[6] = Math.max(0, Math.min(x, previewDisplay.offsetWidth - line.offsetWidth));
                line.style.left = lampPosition[6] + 'px';
            });
        });

        document.addEventListener('DOMContentLoaded', function () {
    // Seleziona tutti i bottoni, i lamp e le small_line
    const lampButtons = document.querySelectorAll('.button');
    const lamps = document.querySelectorAll('.lamp');
    const movablePoint = document.querySelectorAll('.movablePoint');
    const midiToggle = document.querySelector('.midiToggle');

    navigator.permissions.query({ name: "midi", sysex: true }).then((result) => {
    if (result.state === "granted") {
    } else if (result.state === "prompt") {
        alert('Allow MIDI Connection')
    }
    // Permission was denied by user prompt or permission policy
    });

    let midi = null; // global MIDIAccess object
    function onMIDISuccess(midiAccess) {
    console.log("MIDI ready!");
    midi = midiAccess; // store in the global (in real usage, would probably keep in an object instance)
    listInputsAndOutputs(midiAccess);
    }

    function onMIDIFailure(msg) {
    console.error(`Failed to get MIDI access - ${msg}`);
    }


    function onMIDIMessage(event) {
    let str = `MIDI message received at timestamp ${event.timeStamp}[${event.data.length} bytes]: `;
    for (const character of event.data) {
        str += `0x${character.toString(16)} `;
    }
        console.log(str);
    }

    function startLoggingMIDIInput(midiAccess) {
        midiAccess.inputs.forEach((entry) => {
        entry.onmidimessage = onMIDIMessage;
    });
    }

    navigator.requestMIDIAccess().then((access) => {
    // Get lists of available MIDI controllers
    const inputs = access.inputs.values();
    const outputs = access.outputs.values();

    access.onstatechange = (event) => {
        // Print information about the (dis)connected MIDI controller
        console.log(event.port.name, event.port.manufacturer, event.port.state);
    };
    });

  

    navigator.requestMIDIAccess().then((midiAccess) => {
    Array.from(midiAccess.inputs).forEach((input) => {
        input[1].onmidimessage = (msg) => {
            midiToggle.classList.toggle('on');
            setTimeout(() => {
                midiToggle.classList.toggle('on');
            }, 100);

            if(msg.data[1]===24 && msg.data[2]>0){
               
                    let salvatore = document.getElementById('pad1')
                    salvatore.click();
                }
           
        };
    });
    });








    lampButtons.forEach((button, index) => {
        button.addEventListener('click', () => {
        // Spegni tutti i lamp
        lamps.forEach((lamp, lampIndex) => {
            if (lampIndex !== index) {
                lamp.classList.remove('on'); // Spegni lamp non selezionato
                // if (movablePoint[lampIndex]) {
                //     // Nascondi le small_line corrispondenti
                //    // movablePoint[lampIndex].style.visibility = 'hidden';
                //    // movablePoint[lampIndex].style.opacity = 0;
                // }
            }
        })
            // Toggle dello stato del lamp (accende/spegne)
            if (lamps[index]) {
                lamps[index].classList.toggle('on');
                 // Aggiunge/rimuove la classe 'on'
            }

            // Rendi visibile la small_line corrispondente solo se il lamp è acceso
            // if (movablePoint[index]) {
            //     if (lamps[index].classList.contains('on')) {
                    movablePoint[index].style.visibility = 'visible';
           //         movablePoint[index].style.opacity = 1;
                   
            //     } else {
            //         // Se il lamp è spento, nascondi la small_line
            //         movablePoint[index].style.visibility = 'hidden';
            //         movablePoint[index].style.opacity = 0;
            //     }
            // }

        });      
    });       
});


  
    </script>
    <script type="text/javascript" src="/jquery-3.7.1.js"></script>
    <script type="text/javascript" src="/java.js"></script>
</body>
</html>
